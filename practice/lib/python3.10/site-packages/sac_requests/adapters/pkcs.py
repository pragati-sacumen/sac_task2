"""Transport Adapter for use with PKCS12 and X.509 SSL certificate for http request."""
import os
import ssl
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Tuple, Optional
from tempfile import NamedTemporaryFile

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.serialization import (
    Encoding,
    NoEncryption,
    PrivateFormat,
)
from cryptography.hazmat.primitives.serialization.pkcs12 import (
    load_key_and_certificates,
)
from cryptography.x509 import Certificate
from requests.packages.urllib3.poolmanager import (  # type: ignore
    PoolManager,
    ProxyManager,
)

from sac_requests.adapters.timeout import TimeoutHTTPAdapter
from sac_requests.constants.general import CERT, ENCODING, PASSPHRASE, SSL_CONTEXT
from sac_requests.constants.messages import (
    CLIENT_CERTIFICATE_EXPIRED,
    INVALID_CERTIFICATE_PATH,
    INVALID_PASSPHRASE,
    INVALID_PKCS12_CERT,
)


class PKCSAdapter(TimeoutHTTPAdapter):
    """Transport Adapter for use with PKCS12 and X.509 SSL certificate for http request.

    Provides an interface for Requests sessions to contact HTTPS urls and
    authenticate  with an X.509 cert by implementing the Transport Adapter
    interface. This class will need to be manually instantiated and mounted
    to the session

    Usage::

      >>> import requests
      >>> from from sac_requests.adapters.pkcs import PKCSAdapter
      >>> s = requests.Session()
      >>> a = PKCSAdapter(timeout=10, cert='...', passphrase='...', encoding='...')
      >>> s.mount('https://', a)

    :param pool_connections: The number of urllib3 connection pools to cache.
    :type pool_connections: int
    :param pool_maxsize: The maximum number of connections to save in the pool.
    :type pool_maxsize: int
    :param max_retries: The maximum number of retries each connection
        should attempt. Note, this applies only to failed DNS lookups,
        socket connections and connection timeouts, never to requests where
        data has made it to the server. By default, Requests does not retry
        failed connections. If you need granular control over the
        conditions under which we retry a request, import urllib3's
        ``Retry`` class and pass that instead.
    :type max_retries: int or urllib3.Retry
    :param pool_block: Whether the connection pool should block for connections.
    :type pool_block: bool

    :param cert: Path of the Certificate containing contents of a cryptography.x509Certificate
        object using the encoding specified by the ``encoding`` parameter.
    :type cert: str
    :param passphrase: string or utf8 encoded bytes containing the passphrase used for the
        private key. None if unencrypted. Defaults to None.
    :type passphrase: str or bytes
    :param encoding: Enumeration detailing the encoding method used on the ``cert_bytes``
        parameter. Can be either PEM or DER. Defaults to PEM.
    :type encoding: :class: `cryptography.hazmat.primitives.serialization.Encoding`

    :param HTTPAdapter: The built-in HTTP Adapter for urllib3.
    :type HTTPAdapter: HTTPAdapter
    """

    def __init__(self, *args: List[Any], **kwargs: Dict[Any, Any]) -> None:
        """Initialise PKCS12 SSL Adapter."""
        self.cert: str = kwargs.pop(CERT, None)  # type: ignore
        self.passphrase: str = kwargs.pop(PASSPHRASE, None)  # type: ignore
        self.encoding: Encoding = kwargs.pop(ENCODING, Encoding.PEM)
        # Validate the certificate file path and passphrase
        self.__validate_cert()
        # Get the certificate bytes
        cert_bytes, pk_bytes, ca_bytes = self.__get_certificate_bytes()
        # Create the SSL context
        self.ssl_context = self.__create_ssl_context(cert_bytes, pk_bytes, ca_bytes)

        super().__init__(*args, **kwargs)

    def __validate_cert(self) -> None:
        """Validate the certificate file path and passphrase.

        :raises ValueError: Invalid certificate file path.
        :raises ValueError: Empty certificate passphrase.
        """
        if not (self.cert and Path(self.cert).is_file()):
            raise ValueError(INVALID_CERTIFICATE_PATH.format(path=self.cert))

        if self.passphrase is None:
            raise ValueError(INVALID_PASSPHRASE)

        try:
            load_key_and_certificates(
                Path(self.cert).read_bytes(), self.passphrase.encode("utf8")
            )
        except Exception as err:
            raise ValueError(INVALID_PKCS12_CERT.format(path=self.cert, e=err)) from err

    def __check_cert_dates(self, cert: Certificate) -> None:
        """Check the validity dates of the supplied certificate.

        :param cert: Certificate to be checked.
        :type cert: Certificate
        :raises ValueError: Client certificate expired.
        """
        now = datetime.utcnow()
        if cert.not_valid_after < now or cert.not_valid_before > now:
            raise ValueError(
                CLIENT_CERTIFICATE_EXPIRED.format(
                    cert.not_valid_after, cert.not_valid_before
                )
            )

    def __get_certificate_bytes(self) -> Tuple[bytes, bytes, List[bytes]]:
        """Get the certificate bytes.

        :return: Certificate bytes.
        :rtype: Tuple[bytes, bytes, List[bytes]]
        """
        pkcs12_data: bytes = Path(self.cert).read_bytes()

        is_passphrase_bytes = self.passphrase and isinstance(self.passphrase, bytes)
        pkcs12_password_bytes = (
            self.passphrase if is_passphrase_bytes else self.passphrase.encode("utf8")
        )

        backend = default_backend()
        pkcs12_cert = load_key_and_certificates(
            pkcs12_data, pkcs12_password_bytes, backend
        )

        # Get the private key bytes
        pk_bytes = pkcs12_cert[0].private_bytes(
            self.encoding, PrivateFormat.TraditionalOpenSSL, NoEncryption()
        )

        # Check the validity dates of the certificate
        self.__check_cert_dates(pkcs12_cert[1])
        # Get the certificate bytes
        cert_bytes = pkcs12_cert[1].public_bytes(self.encoding)

        # Get the CA bytes
        ca_bytes: List[bytes] = []
        if len(pkcs12_cert) > 2:
            for cert in pkcs12_cert[2]:
                self.__check_cert_dates(cert)
                ca_bytes.append(cert.public_bytes(self.encoding))

        return cert_bytes, pk_bytes, ca_bytes

    def __add_certificates_to_ssl_context(
        self,
        cert: bytes,
        key: bytes,
        ca_certs: List[bytes],
        password: bytes,
        ssl_context: ssl.SSLContext,
    ) -> None:
        """Create temporary files for the certificate, key and CA certificates.

        :param cert: Certificate bytes.
        :type cert: bytes
        :param key: Key bytes.
        :type key: bytes
        :param ca_certs: CA certificate bytes.
        :type ca_certs: List[bytes]
        :param ssl_context: SSL context.
        :type ssl_context: ssl.SSLContext
        """
        # Create a temporary file for the certificate, key and CA certificates
        with NamedTemporaryFile(delete=False) as cert_file:
            try:
                # Write the key to the temporary file
                cert_file.write(key)
                # Write the certificate to the temporary file
                cert_file.write(cert)
                # Write the CA certificates to the temporary file
                for ca_cert in ca_certs:
                    cert_file.write(ca_cert)

                cert_file.flush()
                cert_file.close()

                # Load the certificate and key into the SSL context
                ssl_context.load_cert_chain(cert_file.name, password=password)
            finally:
                # Delete the temporary file
                os.remove(cert_file.name)

    def __create_ssl_context(
        self,
        cert_bytes: bytes,
        pk_bytes: bytes,
        ca_bytes: Optional[List[bytes]] = None,
        password: Optional[bytes] = None,
    ) -> ssl.SSLContext:
        """Create an SSL Context with the supplied cert/password.

        :param cert_byes: cert encoded using the method supplied in the `encoding` parameter
        :type cert_byes: bytes
        :param pk_bytes: private key encoded using the method supplied in the `encoding` parameter
        :type pk_bytes: bytes
        :param ca_bytes: CA certificate encoded using the method supplied in the `encoding` parameter, defaults to None
        :type ca_bytes: Optional[List[bytes]], optional
        :param password: passphrase to be used with the supplied private key. None if unencrypted., defaults to None
        :type password: bytes, optional
        :return: SSL Context
        :rtype: ssl.SSLContext
        """
        ssl_context = ssl.create_default_context()
        self.__add_certificates_to_ssl_context(
            cert_bytes, pk_bytes, ca_bytes, password, ssl_context  # type: ignore
        )
        ssl_context.check_hostname = False
        return ssl_context

    def init_poolmanager(
        self, *args: List[Any], **kwargs: Dict[Any, Any]
    ) -> PoolManager:
        """Initialise the pool manager.

        :return: Pool manager.
        :rtype: PoolManager
        """
        if self.ssl_context:
            kwargs[SSL_CONTEXT] = self.ssl_context  # type: ignore
        return super().init_poolmanager(*args, **kwargs)

    def proxy_manager_for(
        self, *args: List[Any], **kwargs: Dict[Any, Any]
    ) -> ProxyManager:
        """Proxy manager for.

        :return: Proxy manager.
        :rtype: ProxyManager
        """
        if self.ssl_context:
            kwargs[SSL_CONTEXT] = self.ssl_context  # type: ignore
        return super().proxy_manager_for(*args, **kwargs)

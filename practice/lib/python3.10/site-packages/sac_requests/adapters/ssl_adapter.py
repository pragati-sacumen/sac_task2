"""SSL Adapter for Python Requests."""
import ssl
from pathlib import Path
from typing import Any, Dict, List

from requests.packages.urllib3.poolmanager import PoolManager  # type: ignore
from requests.packages.urllib3.poolmanager import ProxyManager
from requests.packages.urllib3.util.ssl_ import SSLContext  # type: ignore

from sac_requests.adapters.timeout import TimeoutHTTPAdapter
from sac_requests.constants.general import CERT, KEY, PASSPHRASE, SSL_CONTEXT
from sac_requests.constants.messages import (
    INVALID_CERTIFICATE_KEY_PATH,
    INVALID_CERTIFICATE_PATH,
)


class SSLAdapter(TimeoutHTTPAdapter):
    """A HTTPS Adapter for Python Requests that allows the choice of the SSL/TLS version negotiated by Requests.

    This can be used either to enforce the choice of high-security TLS versions (where supported), or to work around
    misbehaving servers that fail to correctly negotiate the default TLS version being offered.

    Example usage:
        >>> import requests
        >>> import ssl
        >>> from sac_requests.adapters.ssl import SSLAdapter
        >>> s = requests.Session()
        >>> s.mount('https://', SSLAdapter(ssl.PROTOCOL_TLSv1))

    You can replace the chosen protocol with any that are available in the
    default Python SSL module. All subsequent requests that match the adapter
    prefix will use the chosen SSL version instead of the default.
    This adapter will also attempt to change the SSL/TLS version negotiated by
    Requests when using a proxy. However, this may not always be possible:
    prior to Requests v2.4.0 the adapter did not have access to the proxy setup
    code. In earlier versions of Requests, this adapter will not function
    properly when used with proxies.

    :param HTTPAdapter: The built-in HTTP Adapter for urllib3.
    :type HTTPAdapter: HTTPAdapter
    :return: The SSL Adapter.
    :rtype: SSLAdapter
    """

    def __init__(self, *args: List[Any], **kwargs: Dict[Any, Any]):
        """Initialise SSL Adapter.

        :param ssl_version: The SSL/TLS version to use, defaults to None
        :type ssl_version: int, optional
        """
        self.cert: str = kwargs.pop(CERT, None)  # type: ignore
        self.key: str = kwargs.pop(KEY, None)  # type: ignore
        self.passphrase: str = kwargs.pop(PASSPHRASE, None)  # type: ignore

        # Validate the certificate file path.
        self.__validate_cert()
        # Create the SSL context
        self.ssl_context = self.__create_ssl_context()

        super().__init__(*args, **kwargs)

    def __validate_cert(self) -> None:
        """Validate the certificate file path and passphrase.

        :raises ValueError: Invalid certificate file path.
        :raises ValueError: Empty certificate passphrase.
        """
        if not (self.cert and Path(self.cert).is_file()):
            raise ValueError(INVALID_CERTIFICATE_PATH.format(path=self.cert))

        if self.key and not Path(self.key).is_file():
            raise ValueError(INVALID_CERTIFICATE_KEY_PATH.format(path=self.key))

    def __create_ssl_context(
        self,
    ) -> SSLContext:
        """Create an SSL Context with the supplied certificate and key.

        :return: SSL Context
        :rtype: SSLContext
        """
        ssl_context = ssl.create_default_context()
        ssl_context.load_cert_chain(
            certfile=self.cert, keyfile=self.key, password=self.passphrase
        )
        ssl_context.check_hostname = False
        return ssl_context

    def init_poolmanager(
        self, *args: List[Any], **kwargs: Dict[Any, Any]
    ) -> PoolManager:
        """Initialise the pool manager.

        :return: Pool manager.
        :rtype: PoolManager
        """
        if self.ssl_context:
            kwargs[SSL_CONTEXT] = self.ssl_context
        return super().init_poolmanager(*args, **kwargs)

    def proxy_manager_for(
        self, *args: List[Any], **kwargs: Dict[Any, Any]
    ) -> ProxyManager:
        """Proxy manager for SSL Adapter.

        :return: The proxy manager.
        :rtype: ProxyManager
        """
        if self.ssl_context:
            kwargs[SSL_CONTEXT] = self.ssl_context
        return super().proxy_manager_for(*args, **kwargs)
